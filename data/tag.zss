# Basic tag code that can be used as base for more advanced tag implementations
#===============================================================================
# Functions
#===============================================================================
# Returns tagged in char id

[Function fTagGetPartnerId(add) partnerId]
let partnerId = 0;
for i = 0; numPartner; 1 {
	let member = memberNo + $add;
	if $member > numPartner + 1 {
		let member = 1;
	} else if $member < 1 {
		let member = numPartner + 1;
	}
	if teamSide = 1 {
		let pn = $member * 2 - 1;
	} else {
		let pn = $member * 2;
	}	
	if player($pn),alive {
		let partnerId = player($pn),id;
		break;
	}
}

# Decides if AI switch should happen, returns tagged in char id (function can be overridden locally)
# TODO: Balance default AI switch scaling.
[Function fTagAISwitch(nextPartnerId, previousPartnerId) partnerId]
let partnerId = 0;
if const(TagCommandAIChance) >= rand(1, 100) {
	if command = "TagShiftFwd" {
		let partnerId = $nextPartnerId;
	} else if command = "TagShiftBack" {
		let partnerId = $previousPartnerId;
	}
}

# tagIn Switch explod
[Function fTagSwitchExplod()]
let anim = const(FxTagSwitchAI);
if aiLevel = 0 {
	if gameMode = "versuscoop" {
		let anim = $anim + playerNo;
	} else if gameMode = "netplaysurvivalcoop" || gameMode = "netplayteamcoop" || gameMode = "survivalcoop" || gameMode = "teamcoop" {
		if teamSide = 1 {
			let anim = $anim + playerNo / 2 + 1;
		} else {
			let anim = $anim + playerNo / 2;
		}
	} else {
		let anim = $anim + teamSide;
	}
}
explod{
	# Do note all anims and playsnds on this file are called from gofx.def, not fightfx.air/common.snd
	anim: GO $anim;
	posType: p1;
	pos: 0, floor((const(size.head.pos.y) - const(size.ground.front) / 2 - const(size.ground.back) / 2));
	sprPriority: 5;
	ownPal: 1;
	facing: facing;
	scale: 0.5, 0.5;
	bindTime: -1;
	superMoveTime: -1;
	pauseMoveTime: -1;
	removeOnGetHit: 1;
	ignoreHitPause: 1;
}

#===============================================================================
# StateTagEnteringScreen
#===============================================================================
[StateDef const(StateTagEnteringScreen); 
	type: S; moveType: H; physics: N;
	anim: const(AnimTagEnteringScreen);
	sprPriority: 2; ctrl: 0;
]

screenBound{value: 0; moveCamera: 1, 1; stageBound: 0}
assertSpecial{flag: noTurnTarget}

if time = 0 {
	if facing != player(teamLeader),facing {
		turn{}
	}
	# set starting pos
	posSet{x: const240p(pos x * localScale - (backEdgeBodyDist * localScale + 90) * facing); y: 0}
	# store distance to switch initiation position
	map(_iksys_tagSwitchDist) := abs(pos x - player(teamLeader),pos x);
	# set movement
	velSet{x: min(const240p(const(TagInVelX)), map(_iksys_tagSwitchDist) / const(TagInTime)); y: 0}
	# change active player assignment
	map(_iksys_tagLastId) := player(teamLeader),id;
	tagIn{leader: playerNo}
	call fTagSwitchExplod();
} else {
	mapAdd{map: "_iksys_tagSwitchDist"; value: -vel x}
}

# continue until reaching place where the switch was initiated, but stop in front of enemy
if backEdgeBodyDist >= 0 && (floor(map(_iksys_tagSwitchDist)) <= 0 || p2BodyDist X < const240p(30)) {
	velSet{x: 0; y: 0}
	changeState{value: const(StateStand); ctrl: 1}
}

#===============================================================================
# StateTagLeavingScreen
#===============================================================================
[StateDef const(StateTagLeavingScreen);
	type: S; moveType: I; physics: N;
	anim: const(AnimTagLeavingScreen); sprPriority: -2;
	velSet: 0, 0; faceP2: 1;
	ctrl: 0;
]

screenBound{value: 0; moveCamera: 0, 0; stageBound: 0}

if time = 0 {
	turn{}
}

velSet{x: min(ifElse(const(velocity.run.fwd.x) != 0, const(velocity.run.fwd.x), const(velocity.walk.fwd.x) * 2), const240p(const(TagInVelX))); y: 0}

if backEdgeDist < -const240p(160) || frontEdgeDist < -const240p(160) {
	changeState{value: const(StateTagWaitingOutside)}
}

#===============================================================================
# StateTagWaitingOutside
#===============================================================================
[StateDef const(StateTagWaitingOutside);
	type: A; moveType: I; physics: N;
	anim: const(AnimStanding);
	velSet: 0, 0; ctrl: 0;
]

screenBound{value: 0; moveCamera: 0, 0; stageBound: 0}
assertSpecial{flag: invisible; flag2: noAutoTurn}

# force standby character to always stay outside visible area
posSet{
	x: (player(teamLeader),pos x - player(teamLeader),screenPos x - const240p(160)) * -facing;
	y: player(teamLeader),pos y - player(teamLeader),screenPos y - const240p(160);
}

#===============================================================================
# StateTagJumpingIn
#===============================================================================
[StateDef const(StateTagJumpingIn);
	type: A; moveType: I; physics: N;
	anim: const(AnimTagJumpingIn);
	sprPriority: 2; ctrl: 0;
]

if roundState = 3 {
	screenBound{value: 0; moveCamera: 0, 0; stageBound: 0}
	playerPush{value: 0}
} else {
	screenBound{value: 0; moveCamera: 1, 1; stageBound: 0}
	assertSpecial{flag: noTurnTarget}
}

# the character cannot be hit until he has fully entered the stage
if backEdgeBodyDist <= 0 {
	notHitBy{value: SCA; time: 2}
}

# regain control right after entering screen, in case of active player loss
if !ctrl && backEdgeBodyDist >= 0 {
	ctrlSet{value: 1}
}

if time = 0 {
	if facing != player(teamLeader),facing {
		turn{}
	}
	# set starting pos
	posSet{x: const240p(pos x * localScale - (backEdgeBodyDist * localScale + 90) * facing); y: 0}
	# change active player assignment if the battle still goes on
	if roundState = 2 {
		map(_iksys_tagLastId) := player(teamLeader),id;
		tagIn{leader: playerNo}
		call fTagSwitchExplod();
	}
	velSet{x: const240p(4); y: -const240p(8.75)}
} else {
	gravity{}
	if vel y >= 0 && pos y > 0 {
		velSet{x: 0; y: 0}
		changeState{value: const(StateTagLanding)}
	}
}

#===============================================================================
# StateTagLanding
#===============================================================================
[StateDef const(StateTagLanding);
	type: S; moveType: I; physics: N;
	anim: const(AnimTagLanding);
	sprPriority: 2; ctrl: 0;
]

if time = 0 {
	posSet{y: 0}
}

if animTime >= 0 {
	changeState{value: const(StateStand); ctrl: 1}
}

#===============================================================================
# Global states (executed when in self's state)
#===============================================================================
[StateDef -3]

if !const(Default.Enable.Tag) || isHelper || teamSide = 0 {
	# do nothing, global code disabled locally or executed by helper/stage
} else if roundState = 0 && teamMode = Tag {
	map(_iksys_tagActive) := 1;
	map(_iksys_tagLastId) := 0;
	map(_iksys_tagPartnerId) := 0;
	if playerNo = teamLeader {
		map(_iksys_tagIntroFlag) := 1;
	} else {
		map(_iksys_tagIntroFlag) := 0;
		screenBound{value: 0; moveCamera: 0, 0}
	}
	map(_iksys_tagSwitchCooldown) := 0;
} else if map(_iksys_tagActive) = 1 {
	# fix erratic camera during intros
	if roundState = 1 && playerNo != teamLeader {
		screenBound{value: 0; moveCamera: 0, 0}
	}
	# disable tag over win poses
	if roundState = 4 {
		map(_iksys_tagActive) := 0;
	# alive players
	} else if alive {
		let beingHit = 0;
		ignoreHitPause if moveType = H
			|| getHitVar(isbound) != 0
			|| stateNo = const(StateDownedGetHit_gettingUp) ||
			stateNo = [const(StateAirGetHit_fallRecoveryOnGroundStillFalling), const(StateAirGetHit_fallRecoveryInAir)]
		{
			let beingHit = 1;
		}
		# active player
		if playerNo = teamLeader {
			# delay next check if cooldown is active
			if map(_iksys_tagSwitchCooldown) > 0 {
				mapAdd{map: "_iksys_tagSwitchCooldown"; value: -1}
			# not being hit; standing idle or at least on the ground
			} else if $beingHit = 0 && (stateNo = const(StateStand) || pos y >= 0) {
				# last active player has left the screen or died
				if map(_iksys_tagLastId) = 0
					|| playerId(map(_iksys_tagLastId)),stateNo = playerId(map(_iksys_tagLastId)),const(StateTagWaitingOutside)
					|| playerId(map(_iksys_tagLastId)),alive = 0
				{
					# get partner id in case of tag command
					let partnerId = 0;
					let nextPartnerId = call fTagGetPartnerId(1);
					let previousPartnerId = call fTagGetPartnerId(-1);
					if aiLevel > 0 {
						# id is remembered by AI player, switch will happen at first frame that meets switch conditions
						if map(_iksys_tagPartnerId) = 0 {
							let partnerId = call fTagAISwitch($nextPartnerId, $previousPartnerId);
							map(_iksys_tagPartnerId) := $partnerId;
						}
						let partnerId = map(_iksys_tagPartnerId);
					} else if command = "TagShiftFwd" {
						let partnerId = $nextPartnerId;
					} else if command = "TagShiftBack" {
						let partnerId = $previousPartnerId;
					}
					# having control, command buffered, partner standby
					if ctrl && $partnerId > 0 && playerId($partnerId),stateNo = playerId($partnerId),const(StateTagWaitingOutside) {
						mapSet{map: "_iksys_tagSwitchCooldown"; value: playerId($partnerId),const(TagSwitchCooldown); redirectId: $partnerId}
						map(_iksys_tagPartnerId) := 0;
						lifebarAction{spr: const(MsgPartnerChange), 0}
						tagOut{}
						ctrlSet{value: 0}
						assertSpecial{flag: noHardcodedKeys; flag2: noInput}
						tagIn{stateNo: playerId($partnerId),const(StateTagEnteringScreen); redirectId: $partnerId}
					}
				}
			}
		# partners (not hit)
		} else if $beingHit = 0 {
			# on screen, at the round start / during round
			if roundState = 2
				&& (ctrl || standby || map(_iksys_tagIntroFlag) = 0)
				&& (stateNo = const(StateStand) ||
				(pos y >= 0 && stateNo != [const(StateTagEnteringScreen), const(StateTagWaitingOutside)]))
			{
				map(_iksys_tagIntroFlag) := 1;
				tagOut{stateNo: const(StateTagLeavingScreen)}
			# tagged out, at the round end
			} else if roundState = 3 {
				assertSpecial{flag: noInput}
				if stateNo = const(StateTagWaitingOutside) {
					tagIn{stateNo: const(StateTagJumpingIn)}
				}
			}
		}
	# active player died and hit the ground
	} else if playerNo = teamLeader
		&& stateNo = [const(StateDownedGetHit_hitGroundFromFall), const(StateDownedGetHit_lyingDefeated)]
	{
		map(_iksys_tagActive) := 0;
		# bring next team member
		let partnerId = call fTagGetPartnerId(1);
		if $partnerId > 0 {
			mapSet{map: "_iksys_tagSwitchCooldown"; value: playerId($partnerId),const(TagSwitchCooldown); redirectId: $partnerId}
			lifebarAction{spr: const(MsgPartnerChange), 0}
			tagOut{}
			tagIn{stateNo: playerId($partnerId),const(StateTagJumpingIn); redirectId: $partnerId}
		}
	}
	# Red Life regeneration
	if standby && redLife > 0 && (time % const(TagRedLifeRegenFrames)) = 0 { # every 30 frames (0.5s) by default
		let regenVal = min(redLife, ceil(lifeMax * const(TagRedLifeRegenPercent))); # 0.5% lifeMax by default
		lifeAdd{value: $regenVal; absolute: 1}
		redLifeAdd{value: -$regenVal; absolute: 1}
	}
}
